import Mongoose from 'mongoose'
import { DocumentData, PermissionData, UserPermission, VersionData } from '../types/globals'
import { Doc, Permission, Version } from './mongo-models'
import { countWordsFromContent } from './text-utils'

declare global {
  // allow global `var` declarations
  // eslint-disable-next-line no-var
  var db: Mongoose.Connection | undefined
}

export const getDocuments = async (userId: string) => {
  const documents = await Doc.find({ userId })
  return documents.map((document) => document.toJSON())
}

export const getEverybodysDocuments = async () => {
  const documents = await Doc.find({})
  return documents.map((document) => document.toJSON())
}

export const getVersionsForDoc = async (documentId: string): Promise<VersionData[]> => {
  console.log('\n=== getVersionsForDoc ===')
  console.log('Document ID:', documentId)
  
  try {
    const versions = await Version.find({ documentId })
    console.log('Found versions:', versions.length)
    return versions.map((version) => version.toJSON())
  } catch (error) {
    console.error('Error fetching versions:', error)
    throw error
  }
}

export const createDocument = async (body: Partial<DocumentData>): Promise<DocumentData> => {
  const defaultContent = JSON.stringify([{ type: 'default', children: [{ text: '', highlight: 'none' }],}])
  const document = await Doc.create({ 
    title: body.title, 
    content: defaultContent, 
    userId: body.userId, 
    comments: [],
  })
  await document.save()
  return document.toJSON()
}

export const createPermission = async (body: Partial<PermissionData>): Promise<PermissionData> => {
  const permission = await Permission.create({ 
    documentId: body.documentId, 
    ownerId: body.ownerId, 
    users: [],
    globalPermission: UserPermission.None
  })
  await permission.save()
  return permission.toJSON()
}

export const createOrUpdateVersion = async (documentId: string, document: DocumentData) => {
  const wordCount = countWordsFromContent(document.content)
  const newVersion: Partial<VersionData> = { 
    documentId: documentId,
    ownerId: document.userId,
    name: '',
    createdAt: Date.now(),
    autoGenerated: true,
    wordCount,
    content: document.content
  }

  const versions = await getVersionsForDoc(documentId)
  if (versions.length > 0) {
    const autogenVersions = versions.filter((version) => version.autoGenerated === true)
    if (autogenVersions.length > 0) {
      autogenVersions.sort((a, b) => b.createdAt - a.createdAt)
      const mostRecentVersion = autogenVersions[0]
      
      if (mostRecentVersion.createdAt - Date.now() >= -10800000) { // 3 hour windows
        console.log('updating existing version')
        const updatedVersion = await Version.findByIdAndUpdate(mostRecentVersion.id , {
          content: document.content,
          createdAt: Date.now(),
          wordCount
        }, {returnDocument: 'after'})
        if (!updatedVersion) return null
        return updatedVersion.toJSON()
      }
    }
  }
  console.log('creating new version')

  const version = await Version.create(newVersion)
  await version.save()
  return version.toJSON()
}

export const createVersion = async (body: Partial<VersionData>) => {
  console.log('\n=== createVersion ===')
  console.log('Version data:', body)
  
  try {
    if (!body.documentId || !body.ownerId) {
      throw new Error('Missing required fields: documentId or ownerId')
    }

    // Create the version document
    const version = new Version({ 
      documentId: body.documentId,
      ownerId: body.ownerId,
      name: body.name || '',
      createdAt: body.createdAt || Date.now(),
      autoGenerated: body.autoGenerated || false,
      wordCount: body.wordCount || 0,
      content: body.content // Content can now be an object
    })
    
    // Save and return
    console.log('Saving version...')
    await version.save()
    console.log('Version created successfully:', version.id)
    return version.toJSON()
  } catch (error) {
    console.error('Error creating version:', error)
    throw error
  }
}

export const getDocument = async (id: string) => {
  const document = await Doc.findById(id)
  if (!document) return null
  return document.toJSON()
}

export const getPermission = async (id: string) => {
  const permission = await Permission.findById(id)
  if (!permission) return null
  return permission.toJSON()
}

export const getPermissionByDoc = async (documentId: string) => {
  const permission = await Permission.findOne({ documentId })
  if (!permission) return null
  return permission.toJSON()
}

export const updateDocument = async (id: string, body: Partial<DocumentData>) => {
  const updatedDocument = await Doc.findByIdAndUpdate(id, body, {returnDocument: 'after'})
  if (!updatedDocument) return null
  return updatedDocument.toJSON()
}

export const updatePermissionByDoc = async (documentId: string, body: Partial<PermissionData>) => {
  const updatedPermission = await Permission.findOneAndUpdate({ documentId }, body, {returnDocument: 'after'})
  if (!updatedPermission) return null
  return updatedPermission.toJSON()
}

export const updateVersion = async (id: string, body: Partial<VersionData>) => {
  const updatedVersion = await Version.findByIdAndUpdate(id , body, {returnDocument: 'after'})
  if (!updatedVersion) return null
  return updatedVersion.toJSON()
}

export const deleteDocument = async (id: string) => {
  try {
    await Doc.deleteOne({ _id: id })
  } catch (e) {
    console.log('ERROR:', e)
  }
}

export const deletePermission = async (id: string) => {
  try {
    await Permission.deleteOne({ _id: id })
  } catch (e) {
    console.log('ERROR:', e)
  }
}

export const deletePermissionByDoc = async (documentId: string) => {
  try {
    await Permission.findOneAndDelete({ documentId })
  } catch (e) {
    console.log('ERROR:', e)
  }
}

export const deleteVersion = async (id: string) => {
  try {
    await Version.deleteOne({ _id: id })
  } catch (e) {
    console.log('ERROR:', e)
  }
}